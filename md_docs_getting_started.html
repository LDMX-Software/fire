<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fire: Getting Started</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fire<span id="projectnumber">&#160;v0.19.0</span>
   </div>
   <div id="projectbrief">Framework for sImulation and Reconstruction of Events</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_getting_started.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Getting Started </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >This document is to help users become familiar with the basic workings of <code>fire</code>. It assumes you already have a version of fire built and installed.</p>
<h1><a class="anchor" id="autotoc_md16"></a>
Processors</h1>
<p >Defining a new processor can be done to varying levels of complexity; however, they fall into two distinct groups: configurable and non-configurable.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Non-Configurable</h2>
<p >Non-configurable processors cannot be configured at run time from the python configuration. This makes starting them simpler even if they are slightly less powerful.</p>
<div class="fragment"><div class="line"><span class="comment">// MyProcessor.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;fire/Processor.h&gt;</span></div>
<div class="line"><span class="keyword">class </span>MyProcessor : <span class="keyword">public</span> <a class="code hl_class" href="classfire_1_1Processor.html">fire::Processor</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyProcessor(<span class="keyword">const</span> <a class="code hl_class" href="classfire_1_1config_1_1Parameters.html">fire::config::Parameters</a>&amp; ps)</div>
<div class="line">   : fire::Processor(ps) {}</div>
<div class="line">  ~MyProcessor() = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classfire_1_1Processor.html#a6f1bc98203030e0757a004f3f275cd62">process</a>(<a class="code hl_class" href="classfire_1_1Event.html">fire::Event</a>&amp; event) <span class="keyword">final</span> <span class="keyword">override</span> {</div>
<div class="line">    <span class="comment">// process event here!</span></div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line">DECLARE_PROCESSOR(MyProcessor);</div>
<div class="ttc" id="aclassfire_1_1Event_html"><div class="ttname"><a href="classfire_1_1Event.html">fire::Event</a></div><div class="ttdoc">Event class for interfacing with processors.</div><div class="ttdef"><b>Definition:</b> Event.h:28</div></div>
<div class="ttc" id="aclassfire_1_1Processor_html"><div class="ttname"><a href="classfire_1_1Processor.html">fire::Processor</a></div><div class="ttdoc">Base class for all event processing components.</div><div class="ttdef"><b>Definition:</b> Processor.h:57</div></div>
<div class="ttc" id="aclassfire_1_1Processor_html_a6f1bc98203030e0757a004f3f275cd62"><div class="ttname"><a href="classfire_1_1Processor.html#a6f1bc98203030e0757a004f3f275cd62">fire::Processor::process</a></div><div class="ttdeci">virtual void process(Event &amp;event)=0</div><div class="ttdoc">have the derived processors do what they need to do</div></div>
<div class="ttc" id="aclassfire_1_1config_1_1Parameters_html"><div class="ttname"><a href="classfire_1_1config_1_1Parameters.html">fire::config::Parameters</a></div><div class="ttdoc">Class encapsulating parameters for configuring a processor.</div><div class="ttdef"><b>Definition:</b> Parameters.h:28</div></div>
</div><!-- fragment --><p >This example shows the necessary parts of a new Processor.</p><ol type="1">
<li>Inherits from <code><a class="el" href="classfire_1_1Processor.html" title="Base class for all event processing components.">fire::Processor</a></code></li>
<li>Constructor accepts configuration parameters and passes them to the base class</li>
<li>Destructor is defined (even if it is default)</li>
<li>Definition of the function to do the processing</li>
<li>Calling the declaration macro after class is declared.</li>
</ol>
<p >This processor is already ready to be compiled and added into a Python configuration. Any of the other call backs in this class can then be defined by your derived processor if you see it as useful.</p>
<p >Let's suppose that this processor is compiled into a library called <code>libMyModule.so</code> (perhaps with other processors or tools). Then, we can use this processor with fire from a python configuration file as shown below. </p><div class="fragment"><div class="line"><span class="keyword">import</span> fire.cfg</div>
<div class="line">p = fire.cfg.Process(<span class="stringliteral">&#39;example&#39;</span>)</div>
<div class="line">p.sequence = [</div>
<div class="line">  fire.cfg.Processor(<span class="stringliteral">&#39;eg&#39;</span>,<span class="stringliteral">&#39;MyProcessor&#39;</span>,library=<span class="stringliteral">&#39;/full/path/to/libMyModule.so&#39;</span>)</div>
<div class="line">  ]</div>
</div><!-- fragment --><p> The full path to <code>libMyModule.so</code> only needs to be provided if it is not accessible by <code>ld</code> (i.e. it is not in a directory listed in LD_LIBRARY_PATH or a system directory). Moreover, if the library is accessible by <code>ld</code> and you are on a Linux system (so that the libraries follow the naming format of the example), you could replace the <code>library</code> argument with &lsquo;module='MyModule&rsquo;` to make it easier to read. This second option is more common for larger software sets with many modules.</p>
<p >You can determine if your library is accessible by the linker using some <a href="https://unix.stackexchange.com/a/282207">fancy command line nonsense</a>.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Configurable Processor</h2>
<p >Making a processor configurable from Python is not very complicated on the C++ side, but it introduces many complexities and nuances on the Python side.</p>
<p >On the C++ side, it simply involves expanding the constructor in order to use the passed set of parameters to define member variables. Expanding on the example from above:</p>
<div class="fragment"><div class="line"><span class="comment">// MyProcessor.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;fire/Processor.h&gt;</span></div>
<div class="line"><span class="keyword">class </span>MyProcessor : <span class="keyword">public</span> <a class="code hl_class" href="classfire_1_1Processor.html">fire::Processor</a> {</div>
<div class="line">  <span class="keywordtype">int</span> my_parameter_;</div>
<div class="line">  <span class="keywordtype">double</span> my_required_parameter_;</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyProcessor(<span class="keyword">const</span> <a class="code hl_class" href="classfire_1_1config_1_1Parameters.html">fire::config::Parameters</a>&amp; ps)</div>
<div class="line">   : fire::Processor(ps) {</div>
<div class="line">     my_parameter_ = ps.<a class="code hl_function" href="classfire_1_1config_1_1Parameters.html#ab8c99a73cc43039d4d900f10ed7f15fa">get</a>&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;my_parameter&quot;</span>,1);</div>
<div class="line">     my_required_parameter_ = ps.<a class="code hl_function" href="classfire_1_1config_1_1Parameters.html#ab8c99a73cc43039d4d900f10ed7f15fa">get</a>&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;my_required_parameter&quot;</span>);</div>
<div class="line">   }</div>
<div class="line">  ~MyProcessor() = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classfire_1_1Processor.html#a6f1bc98203030e0757a004f3f275cd62">process</a>(<a class="code hl_class" href="classfire_1_1Event.html">fire::Event</a>&amp; event) <span class="keyword">final</span> <span class="keyword">override</span> {</div>
<div class="line">    <span class="comment">// process event here!</span></div>
<div class="line"> </div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line">DECLARE_PROCESSOR(MyProcessor);</div>
<div class="ttc" id="aclassfire_1_1config_1_1Parameters_html_ab8c99a73cc43039d4d900f10ed7f15fa"><div class="ttname"><a href="classfire_1_1config_1_1Parameters.html#ab8c99a73cc43039d4d900f10ed7f15fa">fire::config::Parameters::get</a></div><div class="ttdeci">const T &amp; get(const std::string &amp;name) const</div><div class="ttdoc">Retrieve the parameter of the given name.</div><div class="ttdef"><b>Definition:</b> Parameters.h:76</div></div>
</div><!-- fragment --><p> This constructor will recieves two parameters that are configurable. Exceptions are thrown if the parameter in Python cannot be converted to the passed type. For example, if <code>my_parameter</code> in Python is set to <code>2.0</code> instead of <code>2</code>.</p><ol type="1">
<li><code>my_parameter_</code> is optional with a default value of <code>1</code>.</li>
<li><code>my_required_parameter</code> is required - i.e. an exception will be thrown if a parameter with that name is not found</li>
</ol>
<p >Now, onto the more complicated Python side. There are three main methods for defining parameters on the Python side of configuration. In everything below, <code>my_proc</code> is the Python object that would be added to <code>p.sequence</code> inside of the configuration script so that the Processor will be used during the run.</p>
<p >First, the base configuration class <code>fire.cfg.Processor</code> allows the user to define parameters directly. This is helpful for small processors that don't have an entire Python module supporting them. </p><div class="fragment"><div class="line">my_proc = fire.cfg.Processor(<span class="stringliteral">&#39;my_proc&#39;</span>,<span class="stringliteral">&#39;MyProcessor&#39;</span>,</div>
<div class="line">                             library=<span class="stringliteral">&#39;/full/path/to/libMyModule.so&#39;</span>,</div>
<div class="line">                             my_parameter = 2, </div>
<div class="line">                             my_required_parameter = 3.0)</div>
</div><!-- fragment --><p >Next, we could wrap the code above into a function. This is helpful for portability because now we can put this function into a Python module that could be imported in the configuration script. Moreover, this isolates the parameter spelling to one location so that the the user does not have to worry about mis-spelling parameters. </p><div class="fragment"><div class="line"><span class="keyword">def </span>MyProcessor(name, req, opt = 2) :</div>
<div class="line">    <span class="keywordflow">return</span> fire.cfg.Processor(name,<span class="stringliteral">&#39;MyProcessor&#39;</span>,</div>
<div class="line">                              library=<span class="stringliteral">&#39;/full/path/to/libMyModule.so&#39;</span>,</div>
<div class="line">                              my_parameter = opt, </div>
<div class="line">                              my_required_parameter = req)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># later inside the python config</span></div>
<div class="line">my_proc = MyProcessor(<span class="stringliteral">&#39;my_proc&#39;</span>,5.0)</div>
</div><!-- fragment --><p >Finally, we can create a child class of the parent configuration class. This is the most complicated method and should only be used if the determination of parameters requires some extra Python functions. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyProcessor(fire.cfg.Processor) :</div>
<div class="line">    <span class="keyword">def </span>__init__(name, req) :</div>
<div class="line">        super().__init__(name,<span class="stringliteral">&#39;MyProcessor&#39;</span>,</div>
<div class="line">                         library=<span class="stringliteral">&#39;/full/path/to/libMyModule.so&#39;</span>)</div>
<div class="line">        self.my_parameter = 2</div>
<div class="line">        self.my_required_parameter = req</div>
<div class="line"> </div>
<div class="line"><span class="comment"># later inside the python config</span></div>
<div class="line">my_proc = MyProcessor(<span class="stringliteral">&#39;my_proc&#39;</span>,5.0)</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Python's variable handling is very dynamic. For us, this means that we need to be very careful that the parameters in Python are spelled the same as the parameters in C++. In Python, the variables provided to <code>fire.cfg.Processor</code> (or defined in <code>__init__</code> for the last option) need to have <b>exactly</b> the same name as the parameter names requested in the constructor of the C++ processor.</dd></dl>
<h1><a class="anchor" id="autotoc_md19"></a>
Data Classes</h1>
<p >The ability of fire to handle the saving and loading of data to and from a file comes from the <a class="el" href="namespacefire_1_1io.html" title="Geant4 does a GLOBAL definition of the keyword TRUE.">fire::io</a> namespace. fire is able to handle all so-called "atomic" types (types with <a href="https://en.cppreference.com/w/cpp/types/numeric_limits">numeric limits</a> defined and <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> of, and <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a> of these types.</p>
<p >This accomodates a lot of workflows, but it doesn't accomodate everything. In order to make fire even more flexible, there is a method of interfacing this serialization procedure with a class that you define.</p>
<p >Below is the <code>MyData</code> class declaration showing the minium structure necessary to interface with fire's serialization method. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;fire/io/Data.h&quot;</span></div>
<div class="line"><span class="keyword">class </span>MyData {</div>
<div class="line">  <span class="keyword">friend</span> <span class="keyword">class </span><a class="code hl_struct" href="structfire_1_1io_1_1access.html">fire::io::access</a>;</div>
<div class="line">  MyData() = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keywordtype">void</span> clear();</div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Data&gt;</div>
<div class="line">  <span class="keywordtype">void</span> attach(Data&amp; d);</div>
<div class="line">};</div>
<div class="ttc" id="astructfire_1_1io_1_1access_html"><div class="ttname"><a href="structfire_1_1io_1_1access.html">fire::io::access</a></div><div class="ttdoc">empty struct for connecting a instance of Data and the type it wraps</div><div class="ttdef"><b>Definition:</b> Access.h:22</div></div>
</div><!-- fragment --><p >The user class has four necessary components:</p><ol type="1">
<li>Your class declares the accessor struct class as a <code>friend</code>.<ul>
<li>This allows the io::Data class access to the (potentially private) methods defined below.</li>
</ul>
</li>
<li>Your class has a (public or private) default constructor.<ul>
<li>The default constructor may be how we initialize the data, so it must be defined and available to <a class="el" href="namespacefire_1_1io.html" title="Geant4 does a GLOBAL definition of the keyword TRUE.">fire::io</a>.</li>
<li>If you don't want other parts of the program using the default constructor, you can declare it <code>private</code>.</li>
</ul>
</li>
<li>Your class has a <code>void clear()</code> method defined which resets the object to an "empty" or "blank" state.<ul>
<li>This is used by fire to reset the data at the end of each event.</li>
<li>Similar to the default constructor, this method can be public or private.</li>
</ul>
</li>
<li>Your class implements a <code>void attach(Data&amp; d)</code> method.<ul>
<li>This method should be private since it should not be called by other parts of your code.</li>
<li>More detail below.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md20"></a>
The attach Method</h2>
<p >This method is where you make the decision on which member variables of your class should be stored to or read from data files and how those variables are named. You do this using the <a class="el" href="classfire_1_1io_1_1Data.html#a2c4abab945793f84892051d38138997e" title="Attach a member object from the our data handle.">fire::io::Data&lt;DataType&gt;::attach</a> method. This is best illustrated with an example.</p>
<div class="fragment"><div class="line"><span class="comment">// member_one_ and member_two_ are members of MyData</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Data&gt;</div>
<div class="line"><span class="keywordtype">void</span> MyData::attach(Data&amp; d) {</div>
<div class="line">  d.attach(<span class="stringliteral">&quot;first_member&quot;</span>, member_one_);</div>
<div class="line">  d.attach(<span class="stringliteral">&quot;another_member&quot;</span>, member_two_);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md21"></a>
Important Comments</h3>
<ul>
<li>The name of a variable on disk (the first argument) and the name of the variable in the class do not need to relate to each other; however, it is common to name them similarly so users of your data files aren't confused.</li>
<li>The name of variables on disk cannot be the same in one <code>attach</code> method, but they can repeat across different classes (similar to member variables).</li>
<li>Passing io::Data as reference (i.e. with the <code>&amp;</code>) is necessary; otherwise, you would attach to a local copy and the real io::Data wouldn't be attached to anything.</li>
<li>The members of MyData you pass to io::Data::attach can be any class that <a class="el" href="namespacefire_1_1io.html" title="Geant4 does a GLOBAL definition of the keyword TRUE.">fire::io</a> can handle. This includes the classes listed above or other classes you have defined following these rules.</li>
</ul>
<h2><a class="anchor" id="autotoc_md22"></a>
ROOT Reading</h2>
<p >As a transitory feature, reading from ROOT files <a class="el" href="namespacefire_1_1io_1_1root.html" title="Reading of ROOT TTree files generated by ROOT-based Framework.">fire::io::root</a> previously produced by a ROOT-based serialization framework has been implemented. In order to effectively read these ROOT files, the user must provide the ROOT dictionaries for the classes that they wish to read. The method used in the testing module in this repository is a good example of how to get this done; that method involves three steps.</p>
<h3><a class="anchor" id="autotoc_md23"></a>
Step 1: Add ROOT macros to your class</h3>
<p >You must include the <code>TObject.h</code> header file in order to have access to these macros. Then use <code>ClassDef(&lt;class-name&gt;,&lt;version&gt;)</code> in the header within the class definition. Finally, use <code>ClassDef(&lt;ns&gt;::&lt;class-name&gt;);</code> in the source file. This lines should be wrapped by preprocessor checks so that users compiling your library <em>without</em> ROOT can still compile it. For example, </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fire/io/Data.h&gt;</span> <span class="comment">// get fire_USE_ROOT definition</span></div>
<div class="line"><span class="preprocessor">#ifdef fire_USE_ROOT</span></div>
<div class="line"><span class="preprocessor">#include &lt;TObject.h&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> <b>Note</b>: ROOT associates the data stored in member variables with the name of that member variable. This means that ROOT will print warnings or event error out if new member variables are added or if member variables change names from when the file was written with ROOT.</p>
<h3><a class="anchor" id="autotoc_md24"></a>
Step 2: Write a LinkDef file.</h3>
<p >This file <em>must</em> end in the string <code>LinkDef.h</code>. The prefix to this can be anything that makes sense to you. The template link def is given below with a few examples of how to list classes. This file should be alongside any other headers in your dictionary. </p><div class="fragment"><div class="line"><span class="comment">// MyEventLinkDef.h</span></div>
<div class="line"><span class="preprocessor">#ifdef __CINT__</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma link off all globals;</span></div>
<div class="line"><span class="preprocessor">#pragma link off all classes;</span></div>
<div class="line"><span class="preprocessor">#pragma link off all functions;</span></div>
<div class="line"><span class="preprocessor">#pragma link C++ nestedclasses;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// always have to list my class</span></div>
<div class="line"><span class="preprocessor">#pragma link C++ class myns::MyClass+;</span></div>
<div class="line"><span class="comment">// include if you want to read vectors of your class</span></div>
<div class="line"><span class="preprocessor">#pragma link C++ class std::vector&lt;myns::MyClass&gt;+;</span></div>
<div class="line"><span class="comment">// include if you want maps of your class </span></div>
<div class="line"><span class="comment">// (key could be anything in dictionary, not just int)</span></div>
<div class="line"><span class="preprocessor">#pragma link C++ class std::map&lt;int,myns::MyClass&gt;+;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md25"></a>
Step 3: CMake Nonsense</h3>
<p >ROOT has written a CMake function that can be used to attach a dictionary compilation to an existing CMake target. It is a bit finnicky, so be careful when deviating from the template below. </p><div class="fragment"><div class="line">find_package(fire REQUIRED 0.13.0)</div>
<div class="line">add_library(MyEvent SHARED &lt;list-source-files&gt;)</div>
<div class="line">target_link_libraries(MyEvent PUBLIC fire::io)</div>
<div class="line">if(fire_USE_ROOT)</div>
<div class="line">  target_include_directories(MyEvent PUBLIC</div>
<div class="line">    &quot;$&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&gt;&quot;</div>
<div class="line">    &quot;$&lt;INSTALL_INTERFACE:${CMAKE_INSTALL_PREFIX}/include&gt;&quot;)</div>
<div class="line">  root_generate_dictionary(MyEventDict</div>
<div class="line">    &lt;list-header-files&gt;</div>
<div class="line">    LINKDEF ${CMAKE_CURRENT_SOURCE_DIR}/include/MyEvent/MyEventLinkDef.h</div>
<div class="line">    MODULE MyEvent)</div>
<div class="line">  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/libMyEVent_rdict.pcm DESTINATION lib)</div>
<div class="line">endif()</div>
</div><!-- fragment --><p> This will include the compilation of a ROOT event dictionary if fire was built with ROOT available.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Schema Evolution</h2>
<p >Oftentimes, there comes a situation where you wish to slightly modify the class representing your data (i.e. "evolve the schema" to be fancy :star:) but you also want to retain the ability to read data files that were produced with the past version of the class. This can be done through modification of the attach method.</p>
<p >By default, the version of the class is zero, but you can increment this version by calling the <code>fire_class_version</code> macro within your class declaration. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyData {</div>
<div class="line">  <a class="code hl_define" href="ClassVersion_8h.html#ae3a4b2932c83cd0cd8557ccf139bde20">fire_class_version</a>(1);</div>
<div class="line">  <span class="comment">// ... rest of declaration omitted</span></div>
<div class="line">};</div>
<div class="ttc" id="aClassVersion_8h_html_ae3a4b2932c83cd0cd8557ccf139bde20"><div class="ttname"><a href="ClassVersion_8h.html#ae3a4b2932c83cd0cd8557ccf139bde20">fire_class_version</a></div><div class="ttdeci">#define fire_class_version(VERS)</div><div class="ttdoc">define the version number for a class</div><div class="ttdef"><b>Definition:</b> ClassVersion.h:83</div></div>
</div><!-- fragment --><p >Then we can handle the various versions that are being read by using <code>version()</code> to find out which version we are trying to interpret. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyData::attach(<a class="code hl_class" href="classfire_1_1io_1_1Data.html">fire::io::Data&lt;MyData&gt;</a>&amp; d) {</div>
<div class="line">  <span class="keywordflow">if</span> (d.<a class="code hl_function" href="classfire_1_1io_1_1AbstractData.html#ab0ae56528ad3d5127dcf0e4f376a6c4a">version</a>() &lt; 1) {</div>
<div class="line">    <span class="comment">// handle prior version 0 here</span></div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// handle current version 1 here</span></div>
<div class="line">  }  </div>
<div class="line">}</div>
<div class="ttc" id="aclassfire_1_1io_1_1AbstractData_html_ab0ae56528ad3d5127dcf0e4f376a6c4a"><div class="ttname"><a href="classfire_1_1io_1_1AbstractData.html#ab0ae56528ad3d5127dcf0e4f376a6c4a">fire::io::AbstractData::version</a></div><div class="ttdeci">int version() const</div><div class="ttdoc">Get the version number for the type we are loading from.</div><div class="ttdef"><b>Definition:</b> AbstractData.h:205</div></div>
<div class="ttc" id="aclassfire_1_1io_1_1Data_html"><div class="ttname"><a href="classfire_1_1io_1_1Data.html">fire::io::Data</a></div><div class="ttdoc">General data set.</div><div class="ttdef"><b>Definition:</b> Data.h:90</div></div>
</div><!-- fragment --><p> This naturally extends to several subsequent versions and clearly shows all users how the data is being transformed when they are reading it off disk.</p>
<dl class="section note"><dt>Note</dt><dd>The attach method is only called once per processing run and therefore it <b>cannot</b> and <b>should not</b> be used to handle more complicated data evolutions involving <em>any</em> sort of calculation. If you are calculating a new variable from an old variable, this falls outside of the realm of schema evolution and needs to be done within a Processor.</dd></dl>
<p>If you need a more robust or complicated method for transforming an old-schema into a new schema, the best option is to define your own specialization of the io::Data class itself. This is what EventHeader and RunHeader do in order to update the ROOT-version of the class into the new HDF5-version.</p>
<p >Now the question becomes, how to "handle" the different versions. This is most easily explained with a few examples.</p>
<h3><a class="anchor" id="autotoc_md27"></a>
New Member</h3>
<p >Most simply, we introduce a new member variable which wasn't in prior versions. This can be achieved by letting the serialization know that for old versions, it shouldn't try to load anything for that member variable from disk. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyData::attach(<a class="code hl_class" href="classfire_1_1io_1_1Data.html">fire::io::Data&lt;MyData&gt;</a>&amp; d) {</div>
<div class="line">  <span class="keywordflow">if</span> (d.<a class="code hl_function" href="classfire_1_1io_1_1AbstractData.html#ab0ae56528ad3d5127dcf0e4f376a6c4a">version</a>() &lt; 1) {</div>
<div class="line">    <span class="keyword">using</span> <a class="code hl_enumeration" href="classfire_1_1io_1_1Data.html#a7a353205fd1c27d9850778d6d3ccfc41">fire::io::Data&lt;MyData&gt;::SaveLoad</a>;</div>
<div class="line">    d.<a class="code hl_function" href="classfire_1_1io_1_1Data.html#a2c4abab945793f84892051d38138997e">attach</a>(<span class="stringliteral">&quot;new_member&quot;</span>, new_member_, SaveLoad::SaveOnly);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    d.<a class="code hl_function" href="classfire_1_1io_1_1Data.html#a2c4abab945793f84892051d38138997e">attach</a>(<span class="stringliteral">&quot;new_member&quot;</span>, new_member_);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclassfire_1_1io_1_1Data_html_a2c4abab945793f84892051d38138997e"><div class="ttname"><a href="classfire_1_1io_1_1Data.html#a2c4abab945793f84892051d38138997e">fire::io::Data::attach</a></div><div class="ttdeci">void attach(const std::string &amp;name, MemberType &amp;m, SaveLoad sl=SaveLoad::Both)</div><div class="ttdoc">Attach a member object from the our data handle.</div><div class="ttdef"><b>Definition:</b> Data.h:188</div></div>
<div class="ttc" id="aclassfire_1_1io_1_1Data_html_a7a353205fd1c27d9850778d6d3ccfc41"><div class="ttname"><a href="classfire_1_1io_1_1Data.html#a7a353205fd1c27d9850778d6d3ccfc41">fire::io::Data::SaveLoad</a></div><div class="ttdeci">SaveLoad</div><div class="ttdoc">Flag how a member variable should be accessed by serialization.</div><div class="ttdef"><b>Definition:</b> Data.h:98</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md28"></a>
Remove Member</h3>
<p >Less often but still possible, we can drop a member variable but still have it read into memory when reading a prior version. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyData::attach(<a class="code hl_class" href="classfire_1_1io_1_1Data.html">fire::io::Data&lt;MyData&gt;</a>&amp; d) {</div>
<div class="line">  <span class="keywordflow">if</span> (d.<a class="code hl_function" href="classfire_1_1io_1_1AbstractData.html#ab0ae56528ad3d5127dcf0e4f376a6c4a">version</a>() &lt; 1) {</div>
<div class="line">    <span class="keyword">using</span> <a class="code hl_enumeration" href="classfire_1_1io_1_1Data.html#a7a353205fd1c27d9850778d6d3ccfc41">fire::io::Data&lt;MyData&gt;::SaveLoad</a>;</div>
<div class="line">    d.<a class="code hl_function" href="classfire_1_1io_1_1Data.html#a2c4abab945793f84892051d38138997e">attach</a>(<span class="stringliteral">&quot;old_member&quot;</span>, old_member_, SaveLoad::LoadOnly);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// we are dropping old_member so we set it to some absurd value</span></div>
<div class="line">    <span class="comment">//   in later versions</span></div>
<div class="line">    old_member_ = 9999;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md29"></a>
Rename</h3>
<p >Also commonly, we want to change the name on disk for a specific member variable. In this case, we just need to let the serialization know that old versions will be loaded from a different location than where they are saved. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyData::attach(<a class="code hl_class" href="classfire_1_1io_1_1Data.html">fire::io::Data&lt;MyData&gt;</a>&amp; d) {</div>
<div class="line">  <span class="keywordflow">if</span> (d.<a class="code hl_function" href="classfire_1_1io_1_1AbstractData.html#ab0ae56528ad3d5127dcf0e4f376a6c4a">version</a>() &lt; 1) {</div>
<div class="line">    <span class="keyword">using</span> <a class="code hl_enumeration" href="classfire_1_1io_1_1Data.html#a7a353205fd1c27d9850778d6d3ccfc41">fire::io::Data&lt;MyData&gt;::SaveLoad</a>;</div>
<div class="line">    d.<a class="code hl_function" href="classfire_1_1io_1_1Data.html#a2c4abab945793f84892051d38138997e">attach</a>(<span class="stringliteral">&quot;old_name&quot;</span>, member_, SaveLoad::LoadOnly);</div>
<div class="line">    d.<a class="code hl_function" href="classfire_1_1io_1_1Data.html#a2c4abab945793f84892051d38138997e">attach</a>(<span class="stringliteral">&quot;new_name&quot;</span>, member_, SaveLoad::SaveOnly);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    d.<a class="code hl_function" href="classfire_1_1io_1_1Data.html#a2c4abab945793f84892051d38138997e">attach</a>(<span class="stringliteral">&quot;new_name&quot;</span>, member_);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> This renaming scheme is expected to be common enough that there is a helper function defined for it. The three lines within the early-version block can be replaced by </p><div class="fragment"><div class="line">d.<a class="code hl_function" href="classfire_1_1io_1_1Data.html#ab6d75e9316a4b293b67ab763d42c3245">rename</a>(<span class="stringliteral">&quot;old_name&quot;</span>,<span class="stringliteral">&quot;new_name&quot;</span>,member_);</div>
<div class="ttc" id="aclassfire_1_1io_1_1Data_html_ab6d75e9316a4b293b67ab763d42c3245"><div class="ttname"><a href="classfire_1_1io_1_1Data.html#ab6d75e9316a4b293b67ab763d42c3245">fire::io::Data::rename</a></div><div class="ttdeci">void rename(const std::string &amp;old_name, const std::string &amp;new_name, MemberType &amp;m)</div><div class="ttdoc">Rename a member variable.</div><div class="ttdef"><b>Definition:</b> Data.h:219</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
