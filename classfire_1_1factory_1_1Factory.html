<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fire: fire::factory::Factory&lt; Prototype, PrototypePtr, PrototypeMakerArgs &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fire<span id="projectnumber">&#160;v0.9.5</span>
   </div>
   <div id="projectbrief">Framework for sImulation and Reconstruction of Events</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classfire_1_1factory_1_1Factory.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classfire_1_1factory_1_1Factory-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">fire::factory::Factory&lt; Prototype, PrototypePtr, PrototypeMakerArgs &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classfire_1_1factory_1_1Factory.html" title="Factory to dynamically create objects derived from a specific prototype class.">Factory</a> to dynamically create objects derived from a specific prototype class.  
 <a href="classfire_1_1factory_1_1Factory.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Factory_8h_source.html">Factory.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7389146aaaee383ec65f3162d40496c9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfire_1_1factory_1_1Factory.html#a7389146aaaee383ec65f3162d40496c9">PrototypeMaker</a> = PrototypePtr(*)(PrototypeMakerArgs...)</td></tr>
<tr class="memdesc:a7389146aaaee383ec65f3162d40496c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">the signature of a function that can be used by this factory to dynamically create a new object.  <a href="classfire_1_1factory_1_1Factory.html#a7389146aaaee383ec65f3162d40496c9">More...</a><br /></td></tr>
<tr class="separator:a7389146aaaee383ec65f3162d40496c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1f722166d2b4b5d950d7470139615b21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfire_1_1factory_1_1Factory.html#a1f722166d2b4b5d950d7470139615b21">declare</a> (const std::string &amp;full_name, <a class="el" href="classfire_1_1factory_1_1Factory.html#a7389146aaaee383ec65f3162d40496c9">PrototypeMaker</a> maker)</td></tr>
<tr class="memdesc:a1f722166d2b4b5d950d7470139615b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">register a new object to be constructible  <a href="classfire_1_1factory_1_1Factory.html#a1f722166d2b4b5d950d7470139615b21">More...</a><br /></td></tr>
<tr class="separator:a1f722166d2b4b5d950d7470139615b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc3419e19651ac4ff287be0c8711dbd"><td class="memItemLeft" align="right" valign="top">PrototypePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfire_1_1factory_1_1Factory.html#afcc3419e19651ac4ff287be0c8711dbd">make</a> (const std::string &amp;full_name, PrototypeMakerArgs... maker_args)</td></tr>
<tr class="memdesc:afcc3419e19651ac4ff287be0c8711dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">make a new object by name  <a href="classfire_1_1factory_1_1Factory.html#afcc3419e19651ac4ff287be0c8711dbd">More...</a><br /></td></tr>
<tr class="separator:afcc3419e19651ac4ff287be0c8711dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97735271ef98a31986754e32ab0afff"><td class="memItemLeft" align="right" valign="top"><a id="ad97735271ef98a31986754e32ab0afff" name="ad97735271ef98a31986754e32ab0afff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Factory</b> (<a class="el" href="classfire_1_1factory_1_1Factory.html">Factory</a> const &amp;)=delete</td></tr>
<tr class="memdesc:ad97735271ef98a31986754e32ab0afff"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete the copy constructor <br /></td></tr>
<tr class="separator:ad97735271ef98a31986754e32ab0afff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fce53f96dd36b1a21efaa04dcb384c"><td class="memItemLeft" align="right" valign="top"><a id="a89fce53f96dd36b1a21efaa04dcb384c" name="a89fce53f96dd36b1a21efaa04dcb384c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classfire_1_1factory_1_1Factory.html">Factory</a> const &amp;)=delete</td></tr>
<tr class="memdesc:a89fce53f96dd36b1a21efaa04dcb384c"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete the assignment operator <br /></td></tr>
<tr class="separator:a89fce53f96dd36b1a21efaa04dcb384c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5ceffd49c6d20884d0a5518ddd3c93a0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classfire_1_1factory_1_1Factory.html">Factory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfire_1_1factory_1_1Factory.html#a5ceffd49c6d20884d0a5518ddd3c93a0">get</a> ()</td></tr>
<tr class="memdesc:a5ceffd49c6d20884d0a5518ddd3c93a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the factory instance  <a href="classfire_1_1factory_1_1Factory.html#a5ceffd49c6d20884d0a5518ddd3c93a0">More...</a><br /></td></tr>
<tr class="separator:a5ceffd49c6d20884d0a5518ddd3c93a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:adcfed85479fc2cb4162492e2f7373145"><td class="memItemLeft" align="right" valign="top"><a id="adcfed85479fc2cb4162492e2f7373145" name="adcfed85479fc2cb4162492e2f7373145"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Factory</b> ()=default</td></tr>
<tr class="memdesc:adcfed85479fc2cb4162492e2f7373145"><td class="mdescLeft">&#160;</td><td class="mdescRight">private constructor to prevent creation <br /></td></tr>
<tr class="separator:adcfed85479fc2cb4162492e2f7373145"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a9ad93abae2e2a57fc98e307fb10f678b"><td class="memItemLeft" align="right" valign="top"><a id="a9ad93abae2e2a57fc98e307fb10f678b" name="a9ad93abae2e2a57fc98e307fb10f678b"></a>
std::unordered_map&lt; std::string, <a class="el" href="classfire_1_1factory_1_1Factory.html#a7389146aaaee383ec65f3162d40496c9">PrototypeMaker</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>library_</b></td></tr>
<tr class="memdesc:a9ad93abae2e2a57fc98e307fb10f678b"><td class="mdescLeft">&#160;</td><td class="mdescRight">library of possible objects to create <br /></td></tr>
<tr class="separator:a9ad93abae2e2a57fc98e307fb10f678b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Prototype, typename PrototypePtr = std::unique_ptr&lt;Prototype&gt;, typename... PrototypeMakerArgs&gt;<br />
class fire::factory::Factory&lt; Prototype, PrototypePtr, PrototypeMakerArgs &gt;</div><p ><a class="el" href="classfire_1_1factory_1_1Factory.html" title="Factory to dynamically create objects derived from a specific prototype class.">Factory</a> to dynamically create objects derived from a specific prototype class. </p>
<p >This factory is a singleton class meaning it cannot be created by the user.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Prototype</td><td>the type of object that this factory creates. This should be the base class that all types in this factory derive from. </td></tr>
    <tr><td class="paramname">PrototypePtr</td><td>the type of pointer to the object By defeault, we use <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr"><code>std::unique_ptr</code></a> for good memory management. </td></tr>
    <tr><td class="paramname">PrototypeMakerArgs</td><td>parameter pack of arguments to pass to the object makers and subsequently the constructor.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md0"></a>
Terminology</h2>
<ul>
<li><a class="el" href="classfire_1_1factory_1_1Factory.html" title="Factory to dynamically create objects derived from a specific prototype class.">Factory</a>: An object that has a look-up table between class names and pointers to functions that can create them</li>
<li>Maker: A function that can create a specific class</li>
<li>Prototype: An abstract base class from which derived classes can be used</li>
</ul>
<h2><a class="anchor" id="autotoc_md1"></a>
Design</h2>
<p >The factory itself works in two steps.</p><ol type="1">
<li>All of the different derived classes "register" or "declare" themselves so that the factory knowns how to create them. This registration is done by providing a "maker" function as well as the name they should be referred to by.</li>
<li>The factory creates any of the registered classes and returns a pointer to it in the form of a prototype-class pointer.</li>
</ol>
<h2><a class="anchor" id="autotoc_md2"></a>
Usage</h2>
<p >Using the factory effecitvely can be done in situations where many classes all follow the same design structure, but have different implementations for specific steps. In order to reflect this "same design structure", we define an abstract base class for all of our derived classes from which to inherit. This abstract base class is our "prototype".</p>
<p >Below is a rudimentary example that shows you the basics of this class.</p>
<h3><a class="anchor" id="autotoc_md3"></a>
A Prototype LibraryEntry</h3>
<p >This <code>LibraryEntry</code> prototype class satisfies our requirements. It also defines a helpful "delcaration" macro for derived classes to use. </p><div class="fragment"><div class="line"><span class="comment">// LibraryEntry.hpp</span></div>
<div class="line"><span class="preprocessor">#ifndef LIBRARYENTRY_HPP</span></div>
<div class="line"><span class="preprocessor">#define LIBRARYENTRY_HPP</span></div>
<div class="line"><span class="comment">// we need the factory template</span></div>
<div class="line"><span class="preprocessor">#include &quot;Factory/Factory.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// this class is our prototype</span></div>
<div class="line"><span class="keyword">class </span>LibraryEntry {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// virtual destructor so we can dynamically create derived classes</span></div>
<div class="line">  <span class="keyword">virtual</span> ~LibraryEntry() = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="comment">// pure virtual function that our derived classes will implement</span></div>
<div class="line">  <span class="keyword">virtual</span> std::string name() = 0;</div>
<div class="line">  <span class="comment">// the factory type that we will use here</span></div>
<div class="line">  <span class="keyword">using</span> <a class="code hl_function" href="classfire_1_1factory_1_1Factory.html#adcfed85479fc2cb4162492e2f7373145">Factory</a> = ::factory::Factory&lt;LibraryEntry&gt;;</div>
<div class="line">};  <span class="comment">// LibraryEntry</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// a macro to help with registering our library entries with our factory</span></div>
<div class="line"><span class="preprocessor">#define DECLARE_LIBRARYENTRY(NS, CLASS)                                \</span></div>
<div class="line"><span class="preprocessor">  namespace NS {                                                       \</span></div>
<div class="line"><span class="preprocessor">  std::unique_ptr&lt;::LibraryEntry&gt; CLASS##Maker() {                     \</span></div>
<div class="line"><span class="preprocessor">    return std::make_unique&lt;CLASS&gt;();                                  \</span></div>
<div class="line"><span class="preprocessor">  }                                                                    \</span></div>
<div class="line"><span class="preprocessor">  __attribute__((constructor)) static void CLASS##Declare() {          \</span></div>
<div class="line"><span class="preprocessor">    ::LibraryEntry::Factory.get().declare(                             \</span></div>
<div class="line"><span class="preprocessor">        std::string(#NS) + &quot;::&quot;</span> + std::string(#CLASS), &amp;CLASS##Maker); \</div>
<div class="line">  }                                                                    \</div>
<div class="line">  }</div>
<div class="line">#endif <span class="comment">// LIBRARYENTRY_HPP</span></div>
<div class="ttc" id="aclassfire_1_1factory_1_1Factory_html_adcfed85479fc2cb4162492e2f7373145"><div class="ttname"><a href="classfire_1_1factory_1_1Factory.html#adcfed85479fc2cb4162492e2f7373145">fire::factory::Factory::Factory</a></div><div class="ttdeci">Factory()=default</div><div class="ttdoc">private constructor to prevent creation</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md4"></a>
Example Derived Classes</h3>
<p >Here are a few example derived classes.</p>
<div class="fragment"><div class="line"><span class="comment">// Book.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;LibraryEntry.hpp&quot;</span></div>
<div class="line"><span class="keyword">namespace </span>library {</div>
<div class="line"><span class="keyword">class </span>Book : <span class="keyword">public</span> LibraryEntry {</div>
<div class="line"> public :</div>
<div class="line">  <span class="keyword">virtual</span> std::string name() final<span class="keyword"> override </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Where the Red Fern Grows&quot;</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">DECLARE_LIBRARYENTRY(library,Book)</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Podcast.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;LibraryEntry.hpp&quot;</span></div>
<div class="line"><span class="keyword">namespace </span>library {</div>
<div class="line"><span class="keyword">namespace </span>audio {</div>
<div class="line"><span class="keyword">class </span>Podcast : <span class="keyword">public</span> LibraryEntry {</div>
<div class="line"> public :</div>
<div class="line">  <span class="keyword">virtual</span> std::string name() final<span class="keyword"> override </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;538 Politics Podcast&quot;</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line">}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">DECLARE_LIBRARYENTRY(library::audio,Podcast)</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Album.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;LibraryEntry.hpp&quot;</span></div>
<div class="line"><span class="keyword">namespace </span>library {</div>
<div class="line"><span class="keyword">namespace </span>audio {</div>
<div class="line"><span class="keyword">class </span>Album : <span class="keyword">public</span> LibraryEntry {</div>
<div class="line"> public :</div>
<div class="line">  <span class="keyword">virtual</span> std::string name() final<span class="keyword"> override </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Kind of Blue&quot;</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line">}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">DECLARE_LIBRARYENTRY(library::audio,Album)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md5"></a>
Executable</h3>
<p >Since the <code>DECLARE_LIBRARYENTRY</code> macro defines a function that is decorated with a compiler attribute causing the function to be called at library-load time, the registration of our various library entries is automatically done before the execution of <code>main</code> (or after if the loadLibrary function is used). For simplicity, let's compile these sources files together with a main defined below.</p>
<div class="fragment"><div class="line"><span class="comment">// main.cxx</span></div>
<div class="line"><span class="preprocessor">#include &quot;LibraryEntry.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="fire_8cxx.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">  std::string full_cpp_name{argv[1]}; </div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    <span class="keyword">auto</span> entry_ptr{LibraryEntry::Factory::get().make(full_cpp_name)};</div>
<div class="line">    std::cout &lt;&lt; entry_ptr-&gt;name() &lt;&lt; std::endl;</div>
<div class="line">  } <span class="keywordflow">catch</span> (<span class="keyword">const</span> factory::FactoryException&amp; e) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: &quot;</span> &lt;&lt;  e.what() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="afire_8cxx_html_a0ddf1224851353fc92bfbff6f499fa97"><div class="ttname"><a href="fire_8cxx.html#a0ddf1224851353fc92bfbff6f499fa97">main</a></div><div class="ttdeci">int main(int argc, char *argv[])</div><div class="ttdoc">definition of fire executable</div><div class="ttdef"><b>Definition:</b> fire.cxx:43</div></div>
</div><!-- fragment --><p >Compiling these files together into the <code>fave-things</code> executable would then lead to the following behavior.</p>
<div class="fragment"><div class="line">$ fave-things library::Book</div>
<div class="line">Where the Red Fern Grows</div>
<div class="line">$ fave-things library::audio::Podcast</div>
<div class="line">538 Politics Podcast</div>
<div class="line">$ fave-things library::audio::Album</div>
<div class="line">Kind of Blue</div>
<div class="line">$ fave-things library::DoesNotExist</div>
<div class="line">ERROR: An <span class="keywordtype">object</span> named library::DoesNotExist has not been declared.</div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7389146aaaee383ec65f3162d40496c9" name="a7389146aaaee383ec65f3162d40496c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7389146aaaee383ec65f3162d40496c9">&#9670;&nbsp;</a></span>PrototypeMaker</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Prototype , typename PrototypePtr  = std::unique_ptr&lt;Prototype&gt;, typename... PrototypeMakerArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfire_1_1factory_1_1Factory.html">fire::factory::Factory</a>&lt; Prototype, PrototypePtr, PrototypeMakerArgs &gt;::<a class="el" href="classfire_1_1factory_1_1Factory.html#a7389146aaaee383ec65f3162d40496c9">PrototypeMaker</a> =  PrototypePtr (*)(PrototypeMakerArgs...)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the signature of a function that can be used by this factory to dynamically create a new object. </p>
<p >This is merely here to make the definition of the <a class="el" href="classfire_1_1factory_1_1Factory.html" title="Factory to dynamically create objects derived from a specific prototype class.">Factory</a> simpler. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1f722166d2b4b5d950d7470139615b21" name="a1f722166d2b4b5d950d7470139615b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f722166d2b4b5d950d7470139615b21">&#9670;&nbsp;</a></span>declare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Prototype , typename PrototypePtr  = std::unique_ptr&lt;Prototype&gt;, typename... PrototypeMakerArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfire_1_1factory_1_1Factory.html">fire::factory::Factory</a>&lt; Prototype, PrototypePtr, PrototypeMakerArgs &gt;::declare </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>full_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfire_1_1factory_1_1Factory.html#a7389146aaaee383ec65f3162d40496c9">PrototypeMaker</a>&#160;</td>
          <td class="paramname"><em>maker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>register a new object to be constructible </p>
<p >We insert the new object into the library after checking that it hasn't been defined before.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfire_1_1Exception.html" title="Standard base exception class with some useful output information.">Exception</a></td><td>if the object has been declared before. This exception can easily be avoided by making sure the declaration macro for a prototype links the name of the PrototypeMaker function to the name of the derived class. This means the user would have a compile-time error rather than a runtime exception.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">full_name</td><td>name to use as a reference for the declared object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maker</td><td>a pointer to a function that can dynamically create an instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ceffd49c6d20884d0a5518ddd3c93a0" name="a5ceffd49c6d20884d0a5518ddd3c93a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ceffd49c6d20884d0a5518ddd3c93a0">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Prototype , typename PrototypePtr  = std::unique_ptr&lt;Prototype&gt;, typename... PrototypeMakerArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classfire_1_1factory_1_1Factory.html">Factory</a> &amp; <a class="el" href="classfire_1_1factory_1_1Factory.html">fire::factory::Factory</a>&lt; Prototype, PrototypePtr, PrototypeMakerArgs &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the factory instance </p>
<p >Using a static function variable gaurantees that the factory is created as soon as it is needed and that it is deleted before the program completes.</p>
<dl class="section return"><dt>Returns</dt><dd>reference to single <a class="el" href="classfire_1_1factory_1_1Factory.html" title="Factory to dynamically create objects derived from a specific prototype class.">Factory</a> instance </dd></dl>

</div>
</div>
<a id="afcc3419e19651ac4ff287be0c8711dbd" name="afcc3419e19651ac4ff287be0c8711dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc3419e19651ac4ff287be0c8711dbd">&#9670;&nbsp;</a></span>make()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Prototype , typename PrototypePtr  = std::unique_ptr&lt;Prototype&gt;, typename... PrototypeMakerArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PrototypePtr <a class="el" href="classfire_1_1factory_1_1Factory.html">fire::factory::Factory</a>&lt; Prototype, PrototypePtr, PrototypeMakerArgs &gt;::make </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>full_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PrototypeMakerArgs...&#160;</td>
          <td class="paramname"><em>maker_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>make a new object by name </p>
<p >We look through the library to find the requested object. If found, we create one and return a pointer to the newly created object. If not found, we raise an exception.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfire_1_1Exception.html" title="Standard base exception class with some useful output information.">Exception</a></td><td>if the input object name could not be found</td></tr>
  </table>
  </dd>
</dl>
<p>The arguments to the maker are determined at compiletime using the template parameters of <a class="el" href="classfire_1_1factory_1_1Factory.html" title="Factory to dynamically create objects derived from a specific prototype class.">Factory</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">full_name</td><td>name of object to create, same name as passed to declare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maker_args</td><td>parameter pack of arguments to pass on to maker</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the parent class that the objects derive from. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/fire/factory/<a class="el" href="Factory_8h_source.html">Factory.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>fire</b></li><li class="navelem"><a class="el" href="namespacefire_1_1factory.html">factory</a></li><li class="navelem"><a class="el" href="classfire_1_1factory_1_1Factory.html">Factory</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
