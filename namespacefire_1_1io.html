<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fire: fire::io Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fire<span id="projectnumber">&#160;v0.15.2</span>
   </div>
   <div id="projectbrief">Framework for sImulation and Reconstruction of Events</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacefire_1_1io.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">fire::io Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>serialization to and from HDF5 files  
<a href="namespacefire_1_1io.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacefire_1_1io_1_1root"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefire_1_1io_1_1root.html">root</a></td></tr>
<tr class="memdesc:namespacefire_1_1io_1_1root"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading of ROOT TTree files generated by ROOT-based Framework. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfire_1_1io_1_1AbstractData.html">AbstractData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-specific base class to hold common data methods.  <a href="classfire_1_1io_1_1AbstractData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfire_1_1io_1_1BaseData.html">BaseData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty data base allowing recursion.  <a href="classfire_1_1io_1_1BaseData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfire_1_1io_1_1constants.html">constants</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure constants vital to serialization method.  <a href="structfire_1_1io_1_1constants.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfire_1_1io_1_1Data.html">Data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General data set.  <a href="classfire_1_1io_1_1Data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfire_1_1io_1_1Data_3_01AtomicType_00_01std_1_1enable__if__t_3_01is__atomic__v_3_01AtomicType_01_4_01_4_01_4.html">Data&lt; AtomicType, std::enable_if_t&lt; is_atomic_v&lt; AtomicType &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfire_1_1io_1_1Data.html" title="General data set.">Data</a> wrapper for atomic types.  <a href="classfire_1_1io_1_1Data_3_01AtomicType_00_01std_1_1enable__if__t_3_01is__atomic__v_3_01AtomicType_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfire_1_1io_1_1Data_3_01ParameterStorage_01_4.html">Data&lt; ParameterStorage &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfire_1_1io_1_1Data.html" title="General data set.">io::Data</a> specialization for <a class="el" href="classfire_1_1io_1_1ParameterStorage.html" title="Provides dynamic parameter storage by interfacing between a map to variants storing parameters and a ...">ParameterStorage</a>  <a href="classfire_1_1io_1_1Data_3_01ParameterStorage_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfire_1_1io_1_1Data_3_01std_1_1map_3_01KeyType_00_01ValType_01_4_01_4.html">Data&lt; std::map&lt; KeyType, ValType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our wrapper around <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>.  <a href="classfire_1_1io_1_1Data_3_01std_1_1map_3_01KeyType_00_01ValType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfire_1_1io_1_1Data_3_01std_1_1vector_3_01ContentType_01_4_01_4.html">Data&lt; std::vector&lt; ContentType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our wrapper around <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>.  <a href="classfire_1_1io_1_1Data_3_01std_1_1vector_3_01ContentType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfire_1_1io_1_1ParameterStorage.html">ParameterStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides dynamic parameter storage by interfacing between a map to variants storing parameters and a h5::Data secialization.  <a href="classfire_1_1io_1_1ParameterStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfire_1_1io_1_1Reader.html">Reader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype for reading files within fire.  <a href="classfire_1_1io_1_1Reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfire_1_1io_1_1Writer.html">Writer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the fire DataSets into a deterministic structure in the output HDF5 data file.  <a href="classfire_1_1io_1_1Writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a72de2f95e2ff93da56d7cfe9bc0a6e0c"><td class="memTemplParams" colspan="2">template&lt;typename AtomicType &gt; </td></tr>
<tr class="memitem:a72de2f95e2ff93da56d7cfe9bc0a6e0c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefire_1_1io.html#a72de2f95e2ff93da56d7cfe9bc0a6e0c">is_atomic</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt; bool, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_arithmetic.html">std::is_arithmetic</a>&lt; AtomicType &gt;::value||<a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a>&lt; AtomicType, <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt;::value &gt;</td></tr>
<tr class="memdesc:a72de2f95e2ff93da56d7cfe9bc0a6e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">HighFive supports many C++ "atomic" types that are used regularly.  <a href="namespacefire_1_1io.html#a72de2f95e2ff93da56d7cfe9bc0a6e0c">More...</a><br /></td></tr>
<tr class="separator:a72de2f95e2ff93da56d7cfe9bc0a6e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4daa8c0068cf8f6c75a396b69adc41df"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefire_1_1io.html#a4daa8c0068cf8f6c75a396b69adc41df">Bool</a> : bool { <b>TRUE</b> = true
, <b>FALSE</b> = false
 }</td></tr>
<tr class="memdesc:a4daa8c0068cf8f6c75a396b69adc41df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean enum aligned with h5py.  <a href="namespacefire_1_1io.html#a4daa8c0068cf8f6c75a396b69adc41df">More...</a><br /></td></tr>
<tr class="separator:a4daa8c0068cf8f6c75a396b69adc41df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aba97cbfb1683301e7cff785cc39cfcbe"><td class="memItemLeft" align="right" valign="top"><a id="aba97cbfb1683301e7cff785cc39cfcbe" name="aba97cbfb1683301e7cff785cc39cfcbe"></a>
HighFive::EnumType&lt; <a class="el" href="namespacefire_1_1io.html#a4daa8c0068cf8f6c75a396b69adc41df">Bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>create_enum_bool</b> ()</td></tr>
<tr class="memdesc:aba97cbfb1683301e7cff785cc39cfcbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">HighFive method for creating the enum data type. <br /></td></tr>
<tr class="separator:aba97cbfb1683301e7cff785cc39cfcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac11d6204f9aa0b840faac38d8ccb22cf"><td class="memTemplParams" colspan="2"><a id="ac11d6204f9aa0b840faac38d8ccb22cf" name="ac11d6204f9aa0b840faac38d8ccb22cf"></a>
template&lt;typename AtomicType &gt; </td></tr>
<tr class="memitem:ac11d6204f9aa0b840faac38d8ccb22cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_atomic_v</b> = <a class="el" href="namespacefire_1_1io.html#a72de2f95e2ff93da56d7cfe9bc0a6e0c">is_atomic</a>&lt;AtomicType&gt;::value</td></tr>
<tr class="memdesc:ac11d6204f9aa0b840faac38d8ccb22cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">shorthand for easier use <br /></td></tr>
<tr class="separator:ac11d6204f9aa0b840faac38d8ccb22cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >serialization to and from HDF5 files </p>
<p >Disk input/output namespace.</p>
<p >Isolation of lower-level interaction with HDF5 files is done here. These classes should never be used directly by the end user except for the example provided below.</p>
<p >The ability of fire to handle the saving and loading of data to and from a file comes from this namespace. fire is able to handle all so-called "atomic" types (types with <a href="https://en.cppreference.com/w/cpp/types/numeric_limits">numeric limits</a> defined and <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> of, and <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a> of these types.</p>
<p >This accomodates a lot of workflows, but it doesn't accomodate everything. In order to make fire even more flexible, there is a method of interfacing this serialization procedure with a class that you define.</p>
<p >Below is the <code>MyData</code> class declaration showing the minium structure necessary to interface with fire's serialization method.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;fire/io/Data.h&quot;</span></div>
<div class="line"><span class="keyword">class </span>MyData {</div>
<div class="line">  <span class="keyword">friend</span> <span class="keyword">class </span><a class="code hl_class" href="classfire_1_1io_1_1Data.html">fire::io::Data</a>&lt;MyData&gt;;</div>
<div class="line">  MyData() = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classfire_1_1io_1_1AbstractData.html#a6091f50e5889e5685bac1a04a16e83dc">clear</a>();</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classfire_1_1io_1_1Data.html#ad52144cd45112a82c4e4eb69739011e5">attach</a>(<a class="code hl_class" href="classfire_1_1io_1_1Data.html">fire::io::Data&lt;MyData&gt;</a>&amp; d);</div>
<div class="line">};</div>
<div class="ttc" id="aclassfire_1_1io_1_1AbstractData_html_a6091f50e5889e5685bac1a04a16e83dc"><div class="ttname"><a href="classfire_1_1io_1_1AbstractData.html#a6091f50e5889e5685bac1a04a16e83dc">fire::io::AbstractData::clear</a></div><div class="ttdeci">virtual void clear()</div><div class="ttdoc">Define the clear function here to handle the most common cases.</div><div class="ttdef"><b>Definition:</b> AbstractData.h:164</div></div>
<div class="ttc" id="aclassfire_1_1io_1_1Data_html"><div class="ttname"><a href="classfire_1_1io_1_1Data.html">fire::io::Data</a></div><div class="ttdoc">General data set.</div><div class="ttdef"><b>Definition:</b> Data.h:269</div></div>
<div class="ttc" id="aclassfire_1_1io_1_1Data_html_ad52144cd45112a82c4e4eb69739011e5"><div class="ttname"><a href="classfire_1_1io_1_1Data.html#ad52144cd45112a82c4e4eb69739011e5">fire::io::Data::attach</a></div><div class="ttdeci">void attach(const std::string &amp;name, MemberType &amp;m)</div><div class="ttdoc">Attach a member object from the our data handle.</div><div class="ttdef"><b>Definition:</b> Data.h:329</div></div>
</div><!-- fragment --><p >The user class has four necessary components:</p><ol type="1">
<li>Your class declares the the wrapping <a class="el" href="classfire_1_1io_1_1Data.html" title="General data set.">io::Data</a> class as a <code>friend</code>.<ul>
<li>This allows the <a class="el" href="classfire_1_1io_1_1Data.html" title="General data set.">io::Data</a> class access to the (potentially private) methods defined below.</li>
</ul>
</li>
<li>Your class has a (public or private) default constructor.<ul>
<li>The default constructor may be how we initialize the data, so it must be defined and available to <a class="el" href="namespacefire_1_1io.html" title="serialization to and from HDF5 files">fire::io</a>.</li>
<li>If you don't want other parts of the program using the default constructor, you can declare it <code>private</code>.</li>
</ul>
</li>
<li>Your class has a <code>void clear()</code> method defined which resets the object to an "empty" or "blank" state.<ul>
<li>This is used by fire to reset the data at the end of each event.</li>
<li>Similar to the default constructor, this method can be public or private.</li>
</ul>
</li>
<li>Your class implements a <code>void attach(<a class="el" href="classfire_1_1io_1_1Data.html" title="General data set.">fire::io::Data</a>&lt;MyData&gt;&amp; d)</code> method.<ul>
<li>This method should be private since it should not be called by other parts of your code.</li>
<li>More detail below.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md30"></a>
The attach Method</h2>
<p >This method is where you make the decision on which member variables of your class should be stored to or read from data files and how those variables are named. You do this using the <a class="el" href="classfire_1_1io_1_1Data.html#ad52144cd45112a82c4e4eb69739011e5" title="Attach a member object from the our data handle.">fire::io::Data&lt;DataType&gt;::attach</a> method. This is best illustrated with an example.</p>
<div class="fragment"><div class="line"><span class="comment">// member_one_ and member_two_ are members of MyData</span></div>
<div class="line"><span class="keywordtype">void</span> MyData::attach(<a class="code hl_class" href="classfire_1_1io_1_1Data.html">fire::io::Data&lt;MyData&gt;</a>&amp; d) {</div>
<div class="line">  d.<a class="code hl_function" href="classfire_1_1io_1_1Data.html#ad52144cd45112a82c4e4eb69739011e5">attach</a>(<span class="stringliteral">&quot;first_member&quot;</span>, member_one_);</div>
<div class="line">  d.<a class="code hl_function" href="classfire_1_1io_1_1Data.html#ad52144cd45112a82c4e4eb69739011e5">attach</a>(<span class="stringliteral">&quot;another_member&quot;</span>, member_two_);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31"></a>
Important Comments</h3>
<ul>
<li>The name of a variable on disk (the first argument) and the name of the variable in the class do not need to relate to each other; however, it is common to name them similarly so users of your data files aren't confused.</li>
<li>The name of variables on disk cannot be the same in one <code>attach</code> method, but they can repeat across different classes (similar to member variables).</li>
<li>Passing <a class="el" href="classfire_1_1io_1_1Data.html" title="General data set.">io::Data</a> as reference (i.e. with the <code>&amp;</code>) is necessary; otherwise, you would attach to a local copy and the real <a class="el" href="classfire_1_1io_1_1Data.html" title="General data set.">io::Data</a> wouldn't be attached to anything.</li>
<li>The members of MyData you pass to <a class="el" href="classfire_1_1io_1_1Data.html#ad52144cd45112a82c4e4eb69739011e5" title="Attach a member object from the our data handle.">io::Data::attach</a> can be any class that <a class="el" href="namespacefire_1_1io.html" title="serialization to and from HDF5 files">fire::io</a> can handle. This includes the classes listed above or other classes you have defined following these rules.</li>
</ul>
<h2><a class="anchor" id="autotoc_md32"></a>
ROOT Reading</h2>
<p >As a transitory feature, reading from ROOT files <a class="el" href="namespacefire_1_1io_1_1root.html" title="Reading of ROOT TTree files generated by ROOT-based Framework.">fire::io::root</a> previously produced by a ROOT-based serialization framework has been implemented. In order to effectively read these ROOT files, the user must provide the ROOT dictionaries for the classes that they wish to read. The method used in the testing module in this repository is a good example of how to get this done; that method involves three steps.</p>
<h3><a class="anchor" id="autotoc_md33"></a>
Step 1: Add ROOT macros to your class</h3>
<p >You must include the <code>TObject.h</code> header file in order to have access to these macros. Then use <code>ClassDef(&lt;class-name&gt;,&lt;version&gt;)</code> in the header within the class definition. Finally, use <code>ClassDef(&lt;ns&gt;::&lt;class-name&gt;);</code> in the source file. This lines should be wrapped by preprocessor checks so that users compiling your library <em>without</em> ROOT can still compile it. For example, </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fire/io/Data.h&gt;</span> <span class="comment">// get fire_USE_ROOT definition</span></div>
<div class="line"><span class="preprocessor">#ifdef fire_USE_ROOT</span></div>
<div class="line"><span class="preprocessor">#include &lt;TObject.h&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> <b>Note</b>: ROOT associates the data stored in member variables with the name of that member variable. This means that ROOT will print warnings or event error out if new member variables are added or if member variables change names from when the file was written with ROOT.</p>
<h3><a class="anchor" id="autotoc_md34"></a>
Step 2: Write a LinkDef file.</h3>
<p >This file <em>must</em> end in the string <code>LinkDef.h</code>. The prefix to this can be anything that makes sense to you. The template link def is given below with a few examples of how to list classes. This file should be alongside any other headers in your dictionary. </p><div class="fragment"><div class="line"><span class="comment">// MyEventLinkDef.h</span></div>
<div class="line"><span class="preprocessor">#ifdef __CINT__</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma link off all globals;</span></div>
<div class="line"><span class="preprocessor">#pragma link off all classes;</span></div>
<div class="line"><span class="preprocessor">#pragma link off all functions;</span></div>
<div class="line"><span class="preprocessor">#pragma link C++ nestedclasses;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// always have to list my class</span></div>
<div class="line"><span class="preprocessor">#pragma link C++ class myns::MyClass+;</span></div>
<div class="line"><span class="comment">// include if you want to read vectors of your class</span></div>
<div class="line"><span class="preprocessor">#pragma link C++ class std::vector&lt;myns::MyClass&gt;+;</span></div>
<div class="line"><span class="comment">// include if you want maps of your class </span></div>
<div class="line"><span class="comment">// (key could be anything in dictionary, not just int)</span></div>
<div class="line"><span class="preprocessor">#pragma link C++ class std::map&lt;int,myns::MyClass&gt;+;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md35"></a>
Step 3: CMake Nonsense</h3>
<p >ROOT has written a CMake function that can be used to attach a dictionary compilation to an existing CMake target. It is a bit finnicky, so be careful when deviating from the template below. </p><div class="fragment"><div class="line">find_package(fire REQUIRED 0.13.0)</div>
<div class="line">add_library(MyEvent SHARED &lt;list-source-files&gt;)</div>
<div class="line">target_link_libraries(MyEvent PUBLIC fire::io)</div>
<div class="line">if(fire_USE_ROOT)</div>
<div class="line">  target_include_directories(MyEvent PUBLIC</div>
<div class="line">    &quot;$&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&gt;&quot;</div>
<div class="line">    &quot;$&lt;INSTALL_INTERFACE:${CMAKE_INSTALL_PREFIX}/include&gt;&quot;)</div>
<div class="line">  root_generate_dictionary(MyEventDict</div>
<div class="line">    &lt;list-header-files&gt;</div>
<div class="line">    LINKDEF ${CMAKE_CURRENT_SOURCE_DIR}/include/MyEvent/MyEventLinkDef.h</div>
<div class="line">    MODULE MyEvent)</div>
<div class="line">  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/libMyEVent_rdict.pcm DESTINATION lib)</div>
<div class="line">endif()</div>
</div><!-- fragment --><p> This will include the compilation of a ROOT event dictionary if fire was built with ROOT available.</p>
<h2><a class="anchor" id="autotoc_md36"></a>
Full Example</h2>
<p >Putting all of these notes together, below is an example class that will read/write the coordinate positions but won't record the variable that is calculated from them.</p>
<p >This isn't an amazing example since <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/math/sqrt.html">std::sqrt</a></code> is pretty fast, but you can perhaps imagine a class that has a time-expensive calculation that should only be done once per event but is also redundant and so it shouldn't waste disk space.</p>
<div class="fragment"><div class="line"><span class="comment">// Point.h</span></div>
<div class="line"><span class="preprocessor">#include &quot;fire/io/Data.h&quot;</span></div>
<div class="line"><span class="preprocessor">#ifdef fire_USE_ROOT</span></div>
<div class="line"><span class="preprocessor">#include &quot;TObject.h&quot;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="keyword">class </span>Point {</div>
<div class="line">  <span class="keywordtype">double</span> x_,y_,z_,mag_;</div>
<div class="line">  <span class="keyword">friend</span> <span class="keyword">class </span><a class="code hl_class" href="classfire_1_1io_1_1Data.html">fire::io::Data</a>&lt;Point&gt;;</div>
<div class="line">  Point() = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classfire_1_1io_1_1AbstractData.html#a6091f50e5889e5685bac1a04a16e83dc">clear</a>();</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classfire_1_1io_1_1Data.html#ad52144cd45112a82c4e4eb69739011e5">attach</a>(<a class="code hl_class" href="classfire_1_1io_1_1Data.html">fire::io::Data&lt;Point&gt;</a>&amp; d);</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  Point(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, <span class="keywordtype">double</span> z);</div>
<div class="line">  <span class="keywordtype">double</span> mag() <span class="keyword">const</span>;</div>
<div class="line"><span class="preprocessor">#ifdef fire_USE_ROOT</span></div>
<div class="line">  ClassDef(Point,1);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Point.cxx</span></div>
<div class="line"><span class="preprocessor">#include &quot;Point.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Point::clear() {</div>
<div class="line">  x_ = 0.;</div>
<div class="line">  y_ = 0.;</div>
<div class="line">  z_ = 0.;</div>
<div class="line">  mag_ = -1.;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span> Point::attach(<a class="code hl_class" href="classfire_1_1io_1_1Data.html">fire::io::Data&lt;Point&gt;</a>&amp; d);</div>
<div class="line">  d.<a class="code hl_function" href="classfire_1_1io_1_1Data.html#ad52144cd45112a82c4e4eb69739011e5">attach</a>(<span class="stringliteral">&quot;x&quot;</span>,x_);</div>
<div class="line">  d.<a class="code hl_function" href="classfire_1_1io_1_1Data.html#ad52144cd45112a82c4e4eb69739011e5">attach</a>(<span class="stringliteral">&quot;y&quot;</span>,y_);</div>
<div class="line">  d.<a class="code hl_function" href="classfire_1_1io_1_1Data.html#ad52144cd45112a82c4e4eb69739011e5">attach</a>(<span class="stringliteral">&quot;z&quot;</span>,z_);</div>
<div class="line">}</div>
<div class="line">Point::Point(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, <span class="keywordtype">double</span> z)</div>
<div class="line">  : x_{x}, y_{y}, z_{z}, mag_{-1.} {</div>
<div class="line">    mag();</div>
<div class="line">  }</div>
<div class="line"><span class="keywordtype">double</span> Point::mag()<span class="keyword"> const </span>{</div>
<div class="line">  <span class="keywordflow">if</span> (mag_ &lt; 0.) {</div>
<div class="line">    mag_ = <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/numeric/math/sqrt.html">std::sqrt</a>(x_*x_+y_*y_+z_*z_);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> mag_;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef fire_USE_ROOT</span></div>
<div class="line">ClassImp(Point);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="ttc" id="asqrt_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/numeric/math/sqrt.html">std::sqrt</a></div><div class="ttdeci">T sqrt(T... args)</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md37"></a>
Access Pattern</h2>
<p >Below is a sketch of how the various <a class="el" href="classfire_1_1io_1_1Data.html" title="General data set.">fire::io::Data</a> template classes interact with each other and the broader fire ecosystem.</p>
<div class="image">
<object type="image/svg+xml" data="fire_io_Data_AccessPattern.svg" style="pointer-events: none;"></object>
</div>
 </div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a72de2f95e2ff93da56d7cfe9bc0a6e0c" name="a72de2f95e2ff93da56d7cfe9bc0a6e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72de2f95e2ff93da56d7cfe9bc0a6e0c">&#9670;&nbsp;</a></span>is_atomic</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AtomicType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacefire_1_1io.html#a72de2f95e2ff93da56d7cfe9bc0a6e0c">fire::io::is_atomic</a> = typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt;bool, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_arithmetic.html">std::is_arithmetic</a>&lt;AtomicType&gt;::value || <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a>&lt;AtomicType, <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>HighFive supports many C++ "atomic" types that are used regularly. </p>
<p >In order to conform to our more flexible structure, I have isolated their deduction into this (currently small) header file.</p>
<p >This will make it easier to fold in future atomic types if we see fit. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a4daa8c0068cf8f6c75a396b69adc41df" name="a4daa8c0068cf8f6c75a396b69adc41df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4daa8c0068cf8f6c75a396b69adc41df">&#9670;&nbsp;</a></span>Bool</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacefire_1_1io.html#a4daa8c0068cf8f6c75a396b69adc41df">fire::io::Bool</a> : bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boolean enum aligned with h5py. </p>
<p >We serialize bools in the same method as h5py so that Python-based analyses are easier. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>fire</b></li><li class="navelem"><a class="el" href="namespacefire_1_1io.html">io</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
