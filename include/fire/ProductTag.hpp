/**
 * @file ProductTag.hpp
 * @brief Class defining the identity of a data product in the event
 * @author Jeremy Mans, University of Minnesota
 */

#ifndef FIRE_PRODUCTTAG_HPP
#define FIRE_PRODUCTTAG_HPP

#include <ostream>
#include <string>
#include <type_traits>
#include <boost/core/demangle.hpp>

namespace fire {

/**
 * @class ProductTag
 * @brief Defines the identity of a product and can be used for searches
 *
 */
class ProductTag {
 public:
  /**
   * Class constructor.
   *
   * Blank/empty parameters are generally considered as wildcards
   * when searches are performed.
   *
   * @param name Product name
   * @param pass Pass name
   * @param type Type name
   */
  ProductTag(const std::string& name, const std::string& pass,
             const std::string& type)
      : name_{name}, pass_{pass}, type_{type} {}

  /**
   * Templated class constructor where we can deduce
   * the type name from the type
   */
  template <typename ProductType>
  ProductTag(const std::string& name, const std::string& pass)
    : name_{name}, pass_{pass}, type_{boost::core::demangle(typeid(ProductType).name())} {}

  /**
   * Get the product name
   */
  const std::string& name() const { return name_; }

  /**
   * Get the product pass name
   */
  const std::string& pass() const { return pass_; }

  /**
   * Get the product type name
   */
  const std::string& type() const { return type_; }

  /**
   * String method for printing this tag in a helpful manner
   */
  friend std::ostream& operator<<(std::ostream& os, const ProductTag& pt) {
    return os << pt.name() << "_" << pt.pass() << "_" << pt.type();
  }

 private:
  /**
   * Get demangled type name
   * https://stackoverflow.com/a/4541470/17617632
   * The std::unique_ptr nonsense is there so we can automatically
   * free the dynamically allocated string generated by such a low-level
   * function.
   */
  static std::string demangle(const char* compiler_name) {
    int status{-1};
    std::unique_ptr<char, void(*)(void*)> demangled {
      abi::__cxa_demangle(compiler_name, NULL, NULL, &status),
      std::free
    };
    return (status == 0) ? demangled.get() : compiler_name;
  }

 private:
  /**
   * Name given to the product
   */
  std::string name_;

  /**
   * Passname given when product was written
   */
  std::string pass_;

  /**
   * Typename of the product
   */
  std::string type_;
};

}  // namespace fire

#endif
