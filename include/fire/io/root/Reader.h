#ifndef FIRE_IO_ROOT_READER_H_
#define FIRE_IO_ROOT_READER_H_

#include <set>

#include "TFile.h"
#include "TTree.h"
#include "TBranch.h"

#include "fire/io/Reader.h"
#include "fire/exception/Exception.h"

/**
 * Reading of ROOT TTree files generated by ROOT-based Framework.
 *
 * The [ROOT-based Framework](https://github.com/LDMX-Software/Framework)
 * is a framework with similar design goals as fire, but built
 * using [CERN's ROOT](root.cern.ch) as its core serialization library.
 */
namespace fire::io::root {

/**
 * Reading ROOT files into our data structures
 *
 * If you are familiar with the ROOT-based Framework,
 * this Reader effectively does tasks done by the 
 * framework::Event and framework::EventFile classes.
 */
class Reader : public ::fire::io::Reader {
 public:
  Reader(const std::string& file_name);
  virtual void load_into(BaseData& d) final override;
  virtual std::vector<std::array<std::string,3>> availableObjects() final override;
  virtual std::string name() const final override;
  virtual std::size_t entries() const final override;
  virtual std::size_t runs() const final override;
  virtual void next() final override;

  template <typename DataType>
  void load(const std::string& name, DataType& obj) {
    // transform h5 directory-style name into branchname
    // of ROOT-based framework
    std::string branch_name{transform(name)};
    // choose TTree to load from
    TTree* tree{event_tree_};
    long int i_entry{i_event_};
    if (branch_name=="RunHeader") {
      tree = run_tree_;
      // RunHeader is only branch on run tree, so we move entry now
      i_run_++;
      i_entry = i_run_;
    }

    if (attached_.find(branch_name) == attached_.end()) {
      attached_.insert(branch_name);
      attach(tree,branch_name,obj);
    }

    // the attach process confirms that the branch exists,
    // so we can call it directly to load the entry into memory
    tree->GetBranch(branch_name.c_str())->GetEntry(i_entry);
  }

  Reader(const Reader&) = delete;
  void operator=(const Reader&) = delete;
 private:
  /**
   * pull out pass and object name, construct branch name
   *
   * static caching map since this function is called so
   * frequently
   */
  static std::string transform(const std::string& dir_name);
 private:
  long int i_event_;
  long int i_run_;
  TFile* file_;
  TTree* event_tree_;
  TTree* run_tree_;
  // branches that have been attached
  std::set<std::string> attached_;
 private:
  template<typename T>
  TBranch* attach(TTree* tree, const std::string& branch_name, T& obj) {
    TBranch* br = tree->GetBranch(branch_name.c_str());
    if (br == 0) {
      throw Exception("NotFound", 
          "Branch "+branch_name+" not found in input ROOT file.");
    }
    if constexpr (std::numeric_limits<T>::is_specialized) {
      br->SetAddress(&obj);
    } else {
      br->SetObject(&obj);
    }
    br->SetStatus(1);
    return br;
  }
};  // Reader

}  // namespace fire::root

#endif
